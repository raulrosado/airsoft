"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kareem";
exports.ids = ["vendor-chunks/kareem"];
exports.modules = {

/***/ "(ssr)/./node_modules/kareem/index.js":
/*!**************************************!*\
  !*** ./node_modules/kareem/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Optional arguments or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPre = function(name, context, args, callback) {\n  if (arguments.length === 3) {\n    callback = args;\n    args = [];\n  }\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  const numAsyncPres = pres.numAsync || 0;\n  let currentPre = 0;\n  let asyncPresLeft = numAsyncPres;\n  let done = false;\n  const $args = args;\n  let shouldSkipWrappedFunction = null;\n\n  if (!numPres) {\n    return nextTick(function() {\n      callback(null);\n    });\n  }\n\n  function next() {\n    if (currentPre >= numPres) {\n      return;\n    }\n    const pre = pres[currentPre];\n\n    if (pre.isAsync) {\n      const args = [\n        decorateNextFn(_next),\n        decorateNextFn(function(error) {\n          if (error) {\n            if (done) {\n              return;\n            }\n            if (error instanceof Kareem.skipWrappedFunction) {\n              shouldSkipWrappedFunction = error;\n            } else {\n              done = true;\n              return callback(error);\n            }\n          }\n          if (--asyncPresLeft === 0 && currentPre >= numPres) {\n            return callback(shouldSkipWrappedFunction);\n          }\n        })\n      ];\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else if (pre.fn.length > 0) {\n      const args = [decorateNextFn(_next)];\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\n      for (let i = 1; i < _args.length; ++i) {\n        if (i === _args.length - 1 && typeof _args[i] === 'function') {\n          continue; // skip callbacks to avoid accidentally calling the callback from a hook\n        }\n        args.push(_args[i]);\n      }\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else {\n      let maybePromiseLike = null;\n      try {\n        maybePromiseLike = pre.fn.call(context);\n      } catch (err) {\n        if (err != null) {\n          return callback(err);\n        }\n      }\n\n      if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(() => _next(), err => _next(err));\n      } else {\n        if (++currentPre >= numPres) {\n          if (asyncPresLeft > 0) {\n            // Leave parallel hooks to run\n            return;\n          } else {\n            return nextTick(function() {\n              callback(shouldSkipWrappedFunction);\n            });\n          }\n        }\n        next();\n      }\n    }\n  }\n\n  next.apply(null, [null].concat(args));\n\n  function _next(error) {\n    if (error) {\n      if (done) {\n        return;\n      }\n      if (error instanceof Kareem.skipWrappedFunction) {\n        shouldSkipWrappedFunction = error;\n      } else {\n        done = true;\n        return callback(error);\n      }\n    }\n\n    if (++currentPre >= numPres) {\n      if (asyncPresLeft > 0) {\n        // Leave parallel hooks to run\n        return;\n      } else {\n        return callback(shouldSkipWrappedFunction);\n      }\n    }\n\n    next.apply(context, arguments);\n  }\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {void}\n */\nKareem.prototype.execPreSync = function(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n\n  for (let i = 0; i < numPres; ++i) {\n    pres[i].fn.apply(context, args || []);\n  }\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPost = function(name, context, args, options, callback) {\n  if (arguments.length < 5) {\n    callback = options;\n    options = null;\n  }\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let currentPost = 0;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    return nextTick(function() {\n      callback.apply(null, [firstError].concat(args));\n    });\n  }\n\n  function next() {\n    const post = posts[currentPost].fn;\n    let numArgs = 0;\n    const argLength = args.length;\n    const newArgs = [];\n    for (let i = 0; i < argLength; ++i) {\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n      if (!args[i] || !args[i]._kareemIgnore) {\n        newArgs.push(args[i]);\n      }\n    }\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        const _cb = decorateNextFn(function(error) {\n          if (error) {\n            if (error instanceof Kareem.overwriteResult) {\n              args = error.args;\n              if (++currentPost >= numPosts) {\n                return callback.call(null, firstError);\n              }\n              return next();\n            }\n            firstError = error;\n          }\n          if (++currentPost >= numPosts) {\n            return callback.call(null, firstError);\n          }\n          next();\n        });\n\n        callMiddlewareFunction(post, context,\n          [firstError].concat(newArgs).concat([_cb]), _cb);\n      } else {\n        if (++currentPost >= numPosts) {\n          return callback.call(null, firstError);\n        }\n        next();\n      }\n    } else {\n      const _cb = decorateNextFn(function(error) {\n        if (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            if (++currentPost >= numPosts) {\n              return callback.apply(null, [null].concat(args));\n            }\n            return next();\n          }\n          firstError = error;\n          return next();\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n\n        next();\n      });\n\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        // Skip error handlers if no error\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        return next();\n      }\n      if (post.length === numArgs + 1) {\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\n      } else {\n        let error;\n        let maybePromiseLike;\n        try {\n          maybePromiseLike = post.apply(context, newArgs);\n        } catch (err) {\n          error = err;\n          firstError = err;\n        }\n\n        if (isPromiseLike(maybePromiseLike)) {\n          return maybePromiseLike.then(\n            (res) => {\n              _cb(res instanceof Kareem.overwriteResult ? res : null);\n            },\n            err => _cb(err)\n          );\n        }\n\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\n          args = maybePromiseLike.args;\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [error].concat(args));\n        }\n\n        next();\n      }\n    }\n  }\n\n  next();\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    _this.execPreSync(name, this, arguments);\n\n    const toReturn = fn.apply(this, arguments);\n\n    const result = _this.execPostSync(name, this, [toReturn]);\n\n    return result[0];\n  };\n};\n\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n  if (options.useErrorHandlers) {\n    return instance.execPost(name, context, args, { error: error }, function(error) {\n      return typeof callback === 'function' && callback(error);\n    });\n  } else {\n    return typeof callback === 'function' && callback(error);\n  }\n}\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options]\n * @param {Boolean} [options.checkForPromise]\n * @returns {void}\n */\nKareem.prototype.wrap = function(name, fn, context, args, options) {\n  const lastArg = (args.length > 0 ? args[args.length - 1] : null);\n  const argsWithoutCb = Array.from(args);\n  typeof lastArg === 'function' && argsWithoutCb.pop();\n  const _this = this;\n\n  options = options || {};\n  const checkForPromise = options.checkForPromise;\n\n  this.execPre(name, context, args, function(error) {\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n      const numCallbackParams = options.numCallbackParams || 0;\n      const errorArgs = options.contextParameter ? [context] : [];\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\n        errorArgs.push(null);\n      }\n      return _handleWrapError(_this, error, name, context, errorArgs,\n        options, lastArg);\n    }\n\n    const numParameters = fn.length;\n    let ret;\n\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args[0];\n      return _cb(null, ...error.args);\n    } else {\n      try {\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\n      } catch (err) {\n        return _cb(err);\n      }\n    }\n\n    if (checkForPromise) {\n      if (isPromiseLike(ret)) {\n        // Thenable, use it\n        return ret.then(\n          res => _cb(null, res),\n          err => _cb(err)\n        );\n      }\n\n      // If `fn()` doesn't have a callback argument and doesn't return a\n      // promise, assume it is sync\n      if (numParameters < argsWithoutCb.length + 1) {\n        return _cb(null, ret);\n      }\n    }\n\n    function _cb() {\n      const argsWithoutError = Array.from(arguments);\n      argsWithoutError.shift();\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\n        argsWithoutError.push(null);\n      }\n      if (arguments[0]) {\n        // Assume error\n        return _handleWrapError(_this, arguments[0], name, context,\n          argsWithoutError, options, lastArg);\n      } else {\n        _this.execPost(name, context, argsWithoutError, function() {\n          if (lastArg === null) {\n            return;\n          }\n          arguments[0]\n            ? lastArg(arguments[0])\n            : lastArg.apply(context, arguments);\n        });\n      }\n    }\n  });\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the\n    // function wrapped in a nextTick()\n    return function() {\n      nextTick(() => fn.apply(this, arguments));\n    };\n  }\n  return function() {\n    const _context = context || this;\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Boolean} [isAsync]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\n  let options = {};\n  if (typeof isAsync === 'object' && isAsync !== null) {\n    options = isAsync;\n    isAsync = options.isAsync;\n  } else if (typeof arguments[1] !== 'boolean') {\n    fn = isAsync;\n    isAsync = false;\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (isAsync) {\n    pres.numAsync = pres.numAsync || 0;\n    ++pres.numAsync;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    clone.numAsync = this._pres.get(key).numAsync;\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    combined.numAsync = sourcePres.numAsync || 0;\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction callMiddlewareFunction(fn, context, args, next) {\n  let maybePromiseLike;\n  try {\n    maybePromiseLike = fn.apply(context, args);\n  } catch (error) {\n    return next(error);\n  }\n\n  if (isPromiseLike(maybePromiseLike)) {\n    maybePromiseLike.then(() => next(), err => next(err));\n  }\n}\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction decorateNextFn(fn) {\n  let called = false;\n  const _this = this;\n  return function() {\n    // Ensure this function can only be called once\n    if (called) {\n      return;\n    }\n    called = true;\n    // Make sure to clear the stack so try/catch doesn't catch errors\n    // in subsequent middleware\n    return nextTick(() => fn.apply(_this, arguments));\n  };\n}\n\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\n  setTimeout(cb, 0);\n};\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMva2FyZWVtL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFR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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haXJzb2Z0Ly4vbm9kZV9tb2R1bGVzL2thcmVlbS9pbmRleC5qcz81ZDcwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gS2FyZWVtKCkge1xuICB0aGlzLl9wcmVzID0gbmV3IE1hcCgpO1xuICB0aGlzLl9wb3N0cyA9IG5ldyBNYXAoKTtcbn1cblxuS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24gPSBmdW5jdGlvbiBza2lwV3JhcHBlZEZ1bmN0aW9uKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbiguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgdGhpcy5hcmdzID0gWy4uLmFyZ3VtZW50c107XG59O1xuXG5LYXJlZW0ub3ZlcndyaXRlUmVzdWx0ID0gZnVuY3Rpb24gb3ZlcndyaXRlUmVzdWx0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEthcmVlbS5vdmVyd3JpdGVSZXN1bHQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIHRoaXMuYXJncyA9IFsuLi5hcmd1bWVudHNdO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFsbCBcInByZVwiIGhvb2tzIGZvciBcIm5hbWVcIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGhvb2sgbmFtZSB0byBleGVjdXRlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGFyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIG9yIGRpcmVjdGx5IHRoZSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGV4ZWN1dGluZyBhbGwgaG9va3MgYXJlIGZpbmlzaGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5leGVjUHJlID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncywgY2FsbGJhY2spIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBjYWxsYmFjayA9IGFyZ3M7XG4gICAgYXJncyA9IFtdO1xuICB9XG4gIGNvbnN0IHByZXMgPSB0aGlzLl9wcmVzLmdldChuYW1lKSB8fCBbXTtcbiAgY29uc3QgbnVtUHJlcyA9IHByZXMubGVuZ3RoO1xuICBjb25zdCBudW1Bc3luY1ByZXMgPSBwcmVzLm51bUFzeW5jIHx8IDA7XG4gIGxldCBjdXJyZW50UHJlID0gMDtcbiAgbGV0IGFzeW5jUHJlc0xlZnQgPSBudW1Bc3luY1ByZXM7XG4gIGxldCBkb25lID0gZmFsc2U7XG4gIGNvbnN0ICRhcmdzID0gYXJncztcbiAgbGV0IHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24gPSBudWxsO1xuXG4gIGlmICghbnVtUHJlcykge1xuICAgIHJldHVybiBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoY3VycmVudFByZSA+PSBudW1QcmVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZSA9IHByZXNbY3VycmVudFByZV07XG5cbiAgICBpZiAocHJlLmlzQXN5bmMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgIGRlY29yYXRlTmV4dEZuKF9uZXh0KSxcbiAgICAgICAgZGVjb3JhdGVOZXh0Rm4oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24gPSBlcnJvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoLS1hc3luY1ByZXNMZWZ0ID09PSAwICYmIGN1cnJlbnRQcmUgPj0gbnVtUHJlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF07XG5cbiAgICAgIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24ocHJlLmZuLCBjb250ZXh0LCBhcmdzLCBhcmdzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHByZS5mbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhcmdzID0gW2RlY29yYXRlTmV4dEZuKF9uZXh0KV07XG4gICAgICBjb25zdCBfYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50cyA6IFtudWxsXS5jb25jYXQoJGFyZ3MpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBfYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA9PT0gX2FyZ3MubGVuZ3RoIC0gMSAmJiB0eXBlb2YgX2FyZ3NbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBjYWxsYmFja3MgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IGNhbGxpbmcgdGhlIGNhbGxiYWNrIGZyb20gYSBob29rXG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKF9hcmdzW2ldKTtcbiAgICAgIH1cblxuICAgICAgY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihwcmUuZm4sIGNvbnRleHQsIGFyZ3MsIGFyZ3NbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF5YmVQcm9taXNlTGlrZSA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBtYXliZVByb21pc2VMaWtlID0gcHJlLmZuLmNhbGwoY29udGV4dCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzUHJvbWlzZUxpa2UobWF5YmVQcm9taXNlTGlrZSkpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlTGlrZS50aGVuKCgpID0+IF9uZXh0KCksIGVyciA9PiBfbmV4dChlcnIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgrK2N1cnJlbnRQcmUgPj0gbnVtUHJlcykge1xuICAgICAgICAgIGlmIChhc3luY1ByZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgLy8gTGVhdmUgcGFyYWxsZWwgaG9va3MgdG8gcnVuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHQuYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG5cbiAgZnVuY3Rpb24gX25leHQoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICAgIHNob3VsZFNraXBXcmFwcGVkRnVuY3Rpb24gPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgrK2N1cnJlbnRQcmUgPj0gbnVtUHJlcykge1xuICAgICAgaWYgKGFzeW5jUHJlc0xlZnQgPiAwKSB7XG4gICAgICAgIC8vIExlYXZlIHBhcmFsbGVsIGhvb2tzIHRvIHJ1blxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dC5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYWxsIFwicHJlXCIgaG9va3MgZm9yIFwibmFtZVwiIHN5bmNocm9ub3VzbHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gQXBwbHkgY3VzdG9tIGFyZ3VtZW50cyB0byB0aGUgaG9va1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUuZXhlY1ByZVN5bmMgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBhcmdzKSB7XG4gIGNvbnN0IHByZXMgPSB0aGlzLl9wcmVzLmdldChuYW1lKSB8fCBbXTtcbiAgY29uc3QgbnVtUHJlcyA9IHByZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJlczsgKytpKSB7XG4gICAgcHJlc1tpXS5mbi5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFsbCBcInBvc3RcIiBob29rcyBmb3IgXCJuYW1lXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBob29rIG5hbWUgdG8gZXhlY3V0ZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBhcmdzIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEBwYXJhbSB7Kn0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIG9yIGRpcmVjdGx5IHRoZSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGV4ZWN1dGluZyBhbGwgaG9va3MgYXJlIGZpbmlzaGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5leGVjUG9zdCA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNSkge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBjb25zdCBwb3N0cyA9IHRoaXMuX3Bvc3RzLmdldChuYW1lKSB8fCBbXTtcbiAgY29uc3QgbnVtUG9zdHMgPSBwb3N0cy5sZW5ndGg7XG4gIGxldCBjdXJyZW50UG9zdCA9IDA7XG5cbiAgbGV0IGZpcnN0RXJyb3IgPSBudWxsO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVycm9yKSB7XG4gICAgZmlyc3RFcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gIH1cblxuICBpZiAoIW51bVBvc3RzKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW2ZpcnN0RXJyb3JdLmNvbmNhdChhcmdzKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGNvbnN0IHBvc3QgPSBwb3N0c1tjdXJyZW50UG9zdF0uZm47XG4gICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgIGNvbnN0IGFyZ0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0FyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ0xlbmd0aDsgKytpKSB7XG4gICAgICBudW1BcmdzICs9IGFyZ3NbaV0gJiYgYXJnc1tpXS5fa2FyZWVtSWdub3JlID8gMCA6IDE7XG4gICAgICBpZiAoIWFyZ3NbaV0gfHwgIWFyZ3NbaV0uX2thcmVlbUlnbm9yZSkge1xuICAgICAgICBuZXdBcmdzLnB1c2goYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RXJyb3IpIHtcbiAgICAgIGlmIChpc0Vycm9ySGFuZGxpbmdNaWRkbGV3YXJlKHBvc3RzW2N1cnJlbnRQb3N0XSwgbnVtQXJncykpIHtcbiAgICAgICAgY29uc3QgX2NiID0gZGVjb3JhdGVOZXh0Rm4oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGVycm9yLmFyZ3M7XG4gICAgICAgICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwobnVsbCwgZmlyc3RFcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKG51bGwsIGZpcnN0RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24ocG9zdCwgY29udGV4dCxcbiAgICAgICAgICBbZmlyc3RFcnJvcl0uY29uY2F0KG5ld0FyZ3MpLmNvbmNhdChbX2NiXSksIF9jYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKG51bGwsIGZpcnN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgX2NiID0gZGVjb3JhdGVOZXh0Rm4oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCkge1xuICAgICAgICAgICAgYXJncyA9IGVycm9yLmFyZ3M7XG4gICAgICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0Vycm9ySGFuZGxpbmdNaWRkbGV3YXJlKHBvc3RzW2N1cnJlbnRQb3N0XSwgbnVtQXJncykpIHtcbiAgICAgICAgLy8gU2tpcCBlcnJvciBoYW5kbGVycyBpZiBubyBlcnJvclxuICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKHBvc3QubGVuZ3RoID09PSBudW1BcmdzICsgMSkge1xuICAgICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHBvc3QsIGNvbnRleHQsIG5ld0FyZ3MuY29uY2F0KFtfY2JdKSwgX2NiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IG1heWJlUHJvbWlzZUxpa2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWF5YmVQcm9taXNlTGlrZSA9IHBvc3QuYXBwbHkoY29udGV4dCwgbmV3QXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShtYXliZVByb21pc2VMaWtlKSkge1xuICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2VMaWtlLnRoZW4oXG4gICAgICAgICAgICAocmVzKSA9PiB7XG4gICAgICAgICAgICAgIF9jYihyZXMgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0ID8gcmVzIDogbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyID0+IF9jYihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXliZVByb21pc2VMaWtlIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCkge1xuICAgICAgICAgIGFyZ3MgPSBtYXliZVByb21pc2VMaWtlLmFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBbZXJyb3JdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFsbCBcInBvc3RcIiBob29rcyBmb3IgXCJuYW1lXCIgc3luY2hyb25vdXNseVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGhvb2sgbmFtZSB0byBleGVjdXRlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGFyZ3MgQXBwbHkgY3VzdG9tIGFyZ3VtZW50cyB0byB0aGUgaG9va1xuICogQHJldHVybnMge0FycmF5fSBUaGUgdXNlZCBhcmd1bWVudHNcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5leGVjUG9zdFN5bmMgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBhcmdzKSB7XG4gIGNvbnN0IHBvc3RzID0gdGhpcy5fcG9zdHMuZ2V0KG5hbWUpIHx8IFtdO1xuICBjb25zdCBudW1Qb3N0cyA9IHBvc3RzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvc3RzOyArK2kpIHtcbiAgICBjb25zdCByZXMgPSBwb3N0c1tpXS5mbi5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcbiAgICBpZiAocmVzIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCkge1xuICAgICAgYXJncyA9IHJlcy5hcmdzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmdzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jaHJvbm91cyB3cmFwcGVyIGZvciBcImZuXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvblxuICovXG5LYXJlZW0ucHJvdG90eXBlLmNyZWF0ZVdyYXBwZXJTeW5jID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gc3luY1dyYXBwZXIoKSB7XG4gICAgX3RoaXMuZXhlY1ByZVN5bmMobmFtZSwgdGhpcywgYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IHRvUmV0dXJuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IF90aGlzLmV4ZWNQb3N0U3luYyhuYW1lLCB0aGlzLCBbdG9SZXR1cm5dKTtcblxuICAgIHJldHVybiByZXN1bHRbMF07XG4gIH07XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlV3JhcEVycm9yKGluc3RhbmNlLCBlcnJvciwgbmFtZSwgY29udGV4dCwgYXJncywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKG9wdGlvbnMudXNlRXJyb3JIYW5kbGVycykge1xuICAgIHJldHVybiBpbnN0YW5jZS5leGVjUG9zdChuYW1lLCBjb250ZXh0LCBhcmdzLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYmFjayhlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBwcmUgaG9va3MsIGZvbGxvd2VkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBwb3N0IGhvb2tzLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheX0gYXJncyBBcHBseSBjdXN0b20gYXJndW1lbnRzIHRvIHRoZSBob29rXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrRm9yUHJvbWlzZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihuYW1lLCBmbiwgY29udGV4dCwgYXJncywgb3B0aW9ucykge1xuICBjb25zdCBsYXN0QXJnID0gKGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IG51bGwpO1xuICBjb25zdCBhcmdzV2l0aG91dENiID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicgJiYgYXJnc1dpdGhvdXRDYi5wb3AoKTtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjaGVja0ZvclByb21pc2UgPSBvcHRpb25zLmNoZWNrRm9yUHJvbWlzZTtcblxuICB0aGlzLmV4ZWNQcmUobmFtZSwgY29udGV4dCwgYXJncywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSkge1xuICAgICAgY29uc3QgbnVtQ2FsbGJhY2tQYXJhbXMgPSBvcHRpb25zLm51bUNhbGxiYWNrUGFyYW1zIHx8IDA7XG4gICAgICBjb25zdCBlcnJvckFyZ3MgPSBvcHRpb25zLmNvbnRleHRQYXJhbWV0ZXIgPyBbY29udGV4dF0gOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSBlcnJvckFyZ3MubGVuZ3RoOyBpIDwgbnVtQ2FsbGJhY2tQYXJhbXM7ICsraSkge1xuICAgICAgICBlcnJvckFyZ3MucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfaGFuZGxlV3JhcEVycm9yKF90aGlzLCBlcnJvciwgbmFtZSwgY29udGV4dCwgZXJyb3JBcmdzLFxuICAgICAgICBvcHRpb25zLCBsYXN0QXJnKTtcbiAgICB9XG5cbiAgICBjb25zdCBudW1QYXJhbWV0ZXJzID0gZm4ubGVuZ3RoO1xuICAgIGxldCByZXQ7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgcmV0ID0gZXJyb3IuYXJnc1swXTtcbiAgICAgIHJldHVybiBfY2IobnVsbCwgLi4uZXJyb3IuYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3NXaXRob3V0Q2IuY29uY2F0KF9jYikpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBfY2IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hlY2tGb3JQcm9taXNlKSB7XG4gICAgICBpZiAoaXNQcm9taXNlTGlrZShyZXQpKSB7XG4gICAgICAgIC8vIFRoZW5hYmxlLCB1c2UgaXRcbiAgICAgICAgcmV0dXJuIHJldC50aGVuKFxuICAgICAgICAgIHJlcyA9PiBfY2IobnVsbCwgcmVzKSxcbiAgICAgICAgICBlcnIgPT4gX2NiKGVycilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYGZuKClgIGRvZXNuJ3QgaGF2ZSBhIGNhbGxiYWNrIGFyZ3VtZW50IGFuZCBkb2Vzbid0IHJldHVybiBhXG4gICAgICAvLyBwcm9taXNlLCBhc3N1bWUgaXQgaXMgc3luY1xuICAgICAgaWYgKG51bVBhcmFtZXRlcnMgPCBhcmdzV2l0aG91dENiLmxlbmd0aCArIDEpIHtcbiAgICAgICAgcmV0dXJuIF9jYihudWxsLCByZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYigpIHtcbiAgICAgIGNvbnN0IGFyZ3NXaXRob3V0RXJyb3IgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzV2l0aG91dEVycm9yLnNoaWZ0KCk7XG4gICAgICBpZiAob3B0aW9ucy5udWxsUmVzdWx0QnlEZWZhdWx0ICYmIGFyZ3NXaXRob3V0RXJyb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFyZ3NXaXRob3V0RXJyb3IucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgLy8gQXNzdW1lIGVycm9yXG4gICAgICAgIHJldHVybiBfaGFuZGxlV3JhcEVycm9yKF90aGlzLCBhcmd1bWVudHNbMF0sIG5hbWUsIGNvbnRleHQsXG4gICAgICAgICAgYXJnc1dpdGhvdXRFcnJvciwgb3B0aW9ucywgbGFzdEFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5leGVjUG9zdChuYW1lLCBjb250ZXh0LCBhcmdzV2l0aG91dEVycm9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAobGFzdEFyZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgID8gbGFzdEFyZyhhcmd1bWVudHNbMF0pXG4gICAgICAgICAgICA6IGxhc3RBcmcuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogRmlsdGVyIGN1cnJlbnQgaW5zdGFuY2UgZm9yIHNvbWV0aGluZyBzcGVjaWZpYyBhbmQgcmV0dXJuIHRoZSBmaWx0ZXJlZCBjbG9uZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZpbHRlciBmdW5jdGlvblxuICogQHJldHVybnMge0thcmVlbX0gVGhlIGNsb25lZCBhbmQgZmlsdGVyZWQgaW5zdGFuY2VcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICBjb25zdCBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcblxuICBjb25zdCBwcmVzID0gQXJyYXkuZnJvbShjbG9uZS5fcHJlcy5rZXlzKCkpO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJlcykge1xuICAgIGNvbnN0IGhvb2tzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkuXG4gICAgICBtYXAoaCA9PiBPYmplY3QuYXNzaWduKHt9LCBoLCB7IG5hbWU6IG5hbWUgfSkpLlxuICAgICAgZmlsdGVyKGZuKTtcblxuICAgIGlmIChob29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNsb25lLl9wcmVzLmRlbGV0ZShuYW1lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGhvb2tzLm51bUFzeW5jID0gaG9va3MuZmlsdGVyKGggPT4gaC5pc0FzeW5jKS5sZW5ndGg7XG5cbiAgICBjbG9uZS5fcHJlcy5zZXQobmFtZSwgaG9va3MpO1xuICB9XG5cbiAgY29uc3QgcG9zdHMgPSBBcnJheS5mcm9tKGNsb25lLl9wb3N0cy5rZXlzKCkpO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgcG9zdHMpIHtcbiAgICBjb25zdCBob29rcyA9IHRoaXMuX3Bvc3RzLmdldChuYW1lKS5cbiAgICAgIG1hcChoID0+IE9iamVjdC5hc3NpZ24oe30sIGgsIHsgbmFtZTogbmFtZSB9KSkuXG4gICAgICBmaWx0ZXIoZm4pO1xuXG4gICAgaWYgKGhvb2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2xvbmUuX3Bvc3RzLmRlbGV0ZShuYW1lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNsb25lLl9wb3N0cy5zZXQobmFtZSwgaG9va3MpO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgYSBcIm5hbWVcIiB0byBleGlzdCBlaXRoZXIgaW4gcHJlIG9yIHBvc3QgaG9va3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gXCJ0cnVlXCIgaWYgZm91bmQsIFwiZmFsc2VcIiBvdGhlcndpc2VcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5oYXNIb29rcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3ByZXMuaGFzKG5hbWUpIHx8IHRoaXMuX3Bvc3RzLmhhcyhuYW1lKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgV3JhcHBlciBmb3IgXCJmblwiIG9uIFwibmFtZVwiIGFuZCByZXR1cm4gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuY3JlYXRlV3JhcHBlciA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKCF0aGlzLmhhc0hvb2tzKG5hbWUpKSB7XG4gICAgLy8gRmFzdCBwYXRoOiBpZiB0aGVyZSdzIG5vIGhvb2tzIGZvciB0aGlzIGZ1bmN0aW9uLCBqdXN0IHJldHVybiB0aGVcbiAgICAvLyBmdW5jdGlvbiB3cmFwcGVkIGluIGEgbmV4dFRpY2soKVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRUaWNrKCgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IF9jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgIF90aGlzLndyYXAobmFtZSwgZm4sIF9jb250ZXh0LCBBcnJheS5mcm9tKGFyZ3VtZW50cyksIG9wdGlvbnMpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBob29rIGZvciBcInByZVwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtCb29sZWFufSBbaXNBc3luY11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byByZWdpc3RlciBmb3IgXCJuYW1lXCJcbiAqIEBwYXJhbSB7bmV2ZXJ9IGVycm9yIFVudXNlZFxuICogQHBhcmFtIHtCb29sZWFufSBbdW5zaGlmdF0gV2hldGVyIHRvIFwicHVzaFwiIG9yIHRvIFwidW5zaGlmdFwiIHRoZSBuZXcgaG9va1xuICogQHJldHVybnMge0thcmVlbX1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5wcmUgPSBmdW5jdGlvbihuYW1lLCBpc0FzeW5jLCBmbiwgZXJyb3IsIHVuc2hpZnQpIHtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgaWYgKHR5cGVvZiBpc0FzeW5jID09PSAnb2JqZWN0JyAmJiBpc0FzeW5jICE9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IGlzQXN5bmM7XG4gICAgaXNBc3luYyA9IG9wdGlvbnMuaXNBc3luYztcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAnYm9vbGVhbicpIHtcbiAgICBmbiA9IGlzQXN5bmM7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJlcyA9IHRoaXMuX3ByZXMuZ2V0KG5hbWUpIHx8IFtdO1xuICB0aGlzLl9wcmVzLnNldChuYW1lLCBwcmVzKTtcblxuICBpZiAoaXNBc3luYykge1xuICAgIHByZXMubnVtQXN5bmMgPSBwcmVzLm51bUFzeW5jIHx8IDA7XG4gICAgKytwcmVzLm51bUFzeW5jO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJlKCkgcmVxdWlyZXMgYSBmdW5jdGlvbiwgZ290IFwiJyArIHR5cGVvZiBmbiArICdcIicpO1xuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHtcbiAgICBwcmVzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBmbjogZm4sIGlzQXN5bmM6IGlzQXN5bmMgfSkpO1xuICB9IGVsc2Uge1xuICAgIHByZXMucHVzaChPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGZuOiBmbiwgaXNBc3luYzogaXNBc3luYyB9KSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgaG9vayBmb3IgXCJwb3N0XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1bnNoaWZ0XSBXaGV0ZXIgdG8gXCJwdXNoXCIgb3IgdG8gXCJ1bnNoaWZ0XCIgdGhlIG5ldyBob29rXG4gKiBAcmV0dXJucyB7S2FyZWVtfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zLCBmbiwgdW5zaGlmdCkge1xuICBjb25zdCBwb3N0cyA9IHRoaXMuX3Bvc3RzLmdldChuYW1lKSB8fCBbXTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1bnNoaWZ0ID0gISFmbjtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcigncG9zdCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24sIGdvdCBcIicgKyB0eXBlb2YgZm4gKyAnXCInKTtcbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSB7XG4gICAgcG9zdHMudW5zaGlmdChPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGZuOiBmbiB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcG9zdHMucHVzaChPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGZuOiBmbiB9KSk7XG4gIH1cbiAgdGhpcy5fcG9zdHMuc2V0KG5hbWUsIHBvc3RzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gKiBAcmV0dXJucyB7S2FyZWVtfSBUaGUgY2xvbmVkIGluc3RhbmNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgbiA9IG5ldyBLYXJlZW0oKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLl9wcmVzLmtleXMoKSkge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fcHJlcy5nZXQoa2V5KS5zbGljZSgpO1xuICAgIGNsb25lLm51bUFzeW5jID0gdGhpcy5fcHJlcy5nZXQoa2V5KS5udW1Bc3luYztcbiAgICBuLl9wcmVzLnNldChrZXksIGNsb25lKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLl9wb3N0cy5rZXlzKCkpIHtcbiAgICBuLl9wb3N0cy5zZXQoa2V5LCB0aGlzLl9wb3N0cy5nZXQoa2V5KS5zbGljZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuO1xufTtcblxuLyoqXG4gKiBNZXJnZSBcIm90aGVyXCIgaW50byBzZWxmIG9yIFwiY2xvbmVcIlxuICogQHBhcmFtIHtLYXJlZW19IG90aGVyIFRoZSBpbnN0YW5jZSB0byBtZXJnZSB3aXRoXG4gKiBAcGFyYW0ge0thcmVlbX0gW2Nsb25lXSBUaGUgaW5zdGFuY2UgdG8gbWVyZ2Ugb250byAoaWYgbm90IGRlZmluZWQsIHVzaW5nIFwidGhpc1wiKVxuICogQHJldHVybnMge0thcmVlbX0gVGhlIG1lcmdlZCBpbnN0YW5jZVxuICovXG5LYXJlZW0ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXIsIGNsb25lKSB7XG4gIGNsb25lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRydWUgOiBjbG9uZTtcbiAgY29uc3QgcmV0ID0gY2xvbmUgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIG90aGVyLl9wcmVzLmtleXMoKSkge1xuICAgIGNvbnN0IHNvdXJjZVByZXMgPSByZXQuX3ByZXMuZ2V0KGtleSkgfHwgW107XG4gICAgY29uc3QgZGVkdXBsaWNhdGVkID0gb3RoZXIuX3ByZXMuZ2V0KGtleSkuXG4gICAgICAvLyBEZWR1cGxpY2F0ZSBiYXNlZCBvbiBgZm5gXG4gICAgICBmaWx0ZXIocCA9PiBzb3VyY2VQcmVzLm1hcChfcCA9PiBfcC5mbikuaW5kZXhPZihwLmZuKSA9PT0gLTEpO1xuICAgIGNvbnN0IGNvbWJpbmVkID0gc291cmNlUHJlcy5jb25jYXQoZGVkdXBsaWNhdGVkKTtcbiAgICBjb21iaW5lZC5udW1Bc3luYyA9IHNvdXJjZVByZXMubnVtQXN5bmMgfHwgMDtcbiAgICBjb21iaW5lZC5udW1Bc3luYyArPSBkZWR1cGxpY2F0ZWQuZmlsdGVyKHAgPT4gcC5pc0FzeW5jKS5sZW5ndGg7XG4gICAgcmV0Ll9wcmVzLnNldChrZXksIGNvbWJpbmVkKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBvdGhlci5fcG9zdHMua2V5cygpKSB7XG4gICAgY29uc3Qgc291cmNlUG9zdHMgPSByZXQuX3Bvc3RzLmdldChrZXkpIHx8IFtdO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZCA9IG90aGVyLl9wb3N0cy5nZXQoa2V5KS5cbiAgICAgIGZpbHRlcihwID0+IHNvdXJjZVBvc3RzLmluZGV4T2YocCkgPT09IC0xKTtcbiAgICByZXQuX3Bvc3RzLnNldChrZXksIHNvdXJjZVBvc3RzLmNvbmNhdChkZWR1cGxpY2F0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKGZuLCBjb250ZXh0LCBhcmdzLCBuZXh0KSB7XG4gIGxldCBtYXliZVByb21pc2VMaWtlO1xuICB0cnkge1xuICAgIG1heWJlUHJvbWlzZUxpa2UgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gIH1cblxuICBpZiAoaXNQcm9taXNlTGlrZShtYXliZVByb21pc2VMaWtlKSkge1xuICAgIG1heWJlUHJvbWlzZUxpa2UudGhlbigoKSA9PiBuZXh0KCksIGVyciA9PiBuZXh0KGVycikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2Uodikge1xuICByZXR1cm4gKHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsICYmIHR5cGVvZiB2LnRoZW4gPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZU5leHRGbihmbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIEVuc3VyZSB0aGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIC8vIE1ha2Ugc3VyZSB0byBjbGVhciB0aGUgc3RhY2sgc28gdHJ5L2NhdGNoIGRvZXNuJ3QgY2F0Y2ggZXJyb3JzXG4gICAgLy8gaW4gc3Vic2VxdWVudCBtaWRkbGV3YXJlXG4gICAgcmV0dXJuIG5leHRUaWNrKCgpID0+IGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuY29uc3QgbmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiBwcm9jZXNzLm5leHRUaWNrIHx8IGZ1bmN0aW9uIG5leHRUaWNrKGNiKSB7XG4gIHNldFRpbWVvdXQoY2IsIDApO1xufTtcblxuZnVuY3Rpb24gaXNFcnJvckhhbmRsaW5nTWlkZGxld2FyZShwb3N0LCBudW1BcmdzKSB7XG4gIGlmIChwb3N0LmVycm9ySGFuZGxlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBwb3N0LmZuLmxlbmd0aCA9PT0gbnVtQXJncyArIDI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2FyZWVtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/kareem/index.js\n");

/***/ })

};
;