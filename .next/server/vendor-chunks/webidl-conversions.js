"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webidl-conversions";
exports.ids = ["vendor-chunks/webidl-conversions"];
exports.modules = {

/***/ "(ssr)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction makeException(ErrorType, message, options) {\n  if (options.globals) {\n    ErrorType = options.globals[ErrorType.name];\n  }\n  return new ErrorType(`${options.context ? options.context : \"Value\"} ${message}.`);\n}\n\nfunction toNumber(value, options) {\n  if (typeof value === \"bigint\") {\n    throw makeException(TypeError, \"is a BigInt which cannot be converted to a number\", options);\n  }\n  if (!options.globals) {\n    return Number(value);\n  }\n  return options.globals.Number(value);\n}\n\n// Round x to the nearest integer, choosing the even integer if it lies halfway between two.\nfunction evenRound(x) {\n  // There are four cases for numbers with fractional part being .5:\n  //\n  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n  // (where n is a non-negative integer)\n  //\n  // Branch here for cases 1 and 4\n  if ((x > 0 && (x % 1) === +0.5 && (x & 1) === 0) ||\n        (x < 0 && (x % 1) === -0.5 && (x & 1) === 1)) {\n    return censorNegativeZero(Math.floor(x));\n  }\n\n  return censorNegativeZero(Math.round(x));\n}\n\nfunction integerPart(n) {\n  return censorNegativeZero(Math.trunc(n));\n}\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\nfunction modulo(x, y) {\n  // https://tc39.github.io/ecma262/#eqn-modulo\n  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\n  const signMightNotMatch = x % y;\n  if (sign(y) !== sign(signMightNotMatch)) {\n    return signMightNotMatch + y;\n  }\n  return signMightNotMatch;\n}\n\nfunction censorNegativeZero(x) {\n  return x === 0 ? 0 : x;\n}\n\nfunction createIntegerConversion(bitLength, { unsigned }) {\n  let lowerBound, upperBound;\n  if (unsigned) {\n    lowerBound = 0;\n    upperBound = 2 ** bitLength - 1;\n  } else {\n    lowerBound = -(2 ** (bitLength - 1));\n    upperBound = 2 ** (bitLength - 1) - 1;\n  }\n\n  const twoToTheBitLength = 2 ** bitLength;\n  const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);\n\n  return (value, options = {}) => {\n    let x = toNumber(value, options);\n    x = censorNegativeZero(x);\n\n    if (options.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", options);\n      }\n\n      x = integerPart(x);\n\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(\n          TypeError,\n          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,\n          options\n        );\n      }\n\n      return x;\n    }\n\n    if (!Number.isNaN(x) && options.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n    x = integerPart(x);\n\n    // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\n    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\n    if (x >= lowerBound && x <= upperBound) {\n      return x;\n    }\n\n    // These will not work great for bitLength of 64, but oh well. See the README for more details.\n    x = modulo(x, twoToTheBitLength);\n    if (!unsigned && x >= twoToOneLessThanTheBitLength) {\n      return x - twoToTheBitLength;\n    }\n    return x;\n  };\n}\n\nfunction createLongLongConversion(bitLength, { unsigned }) {\n  const upperBound = Number.MAX_SAFE_INTEGER;\n  const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;\n  const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;\n\n  return (value, options = {}) => {\n    let x = toNumber(value, options);\n    x = censorNegativeZero(x);\n\n    if (options.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", options);\n      }\n\n      x = integerPart(x);\n\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(\n          TypeError,\n          `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,\n          options\n        );\n      }\n\n      return x;\n    }\n\n    if (!Number.isNaN(x) && options.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n\n    let xBigInt = BigInt(integerPart(x));\n    xBigInt = asBigIntN(bitLength, xBigInt);\n    return Number(xBigInt);\n  };\n}\n\nexports.any = value => {\n  return value;\n};\n\nexports.undefined = () => {\n  return undefined;\n};\n\nexports.boolean = value => {\n  return Boolean(value);\n};\n\nexports.byte = createIntegerConversion(8, { unsigned: false });\nexports.octet = createIntegerConversion(8, { unsigned: true });\n\nexports.short = createIntegerConversion(16, { unsigned: false });\nexports[\"unsigned short\"] = createIntegerConversion(16, { unsigned: true });\n\nexports.long = createIntegerConversion(32, { unsigned: false });\nexports[\"unsigned long\"] = createIntegerConversion(32, { unsigned: true });\n\nexports[\"long long\"] = createLongLongConversion(64, { unsigned: false });\nexports[\"unsigned long long\"] = createLongLongConversion(64, { unsigned: true });\n\nexports.double = (value, options = {}) => {\n  const x = toNumber(value, options);\n\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", options);\n  }\n\n  return x;\n};\n\nexports[\"unrestricted double\"] = (value, options = {}) => {\n  const x = toNumber(value, options);\n\n  return x;\n};\n\nexports.float = (value, options = {}) => {\n  const x = toNumber(value, options);\n\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", options);\n  }\n\n  if (Object.is(x, -0)) {\n    return x;\n  }\n\n  const y = Math.fround(x);\n\n  if (!Number.isFinite(y)) {\n    throw makeException(TypeError, \"is outside the range of a single-precision floating-point value\", options);\n  }\n\n  return y;\n};\n\nexports[\"unrestricted float\"] = (value, options = {}) => {\n  const x = toNumber(value, options);\n\n  if (isNaN(x)) {\n    return x;\n  }\n\n  if (Object.is(x, -0)) {\n    return x;\n  }\n\n  return Math.fround(x);\n};\n\nexports.DOMString = (value, options = {}) => {\n  if (options.treatNullAsEmptyString && value === null) {\n    return \"\";\n  }\n\n  if (typeof value === \"symbol\") {\n    throw makeException(TypeError, \"is a symbol, which cannot be converted to a string\", options);\n  }\n\n  const StringCtor = options.globals ? options.globals.String : String;\n  return StringCtor(value);\n};\n\nexports.ByteString = (value, options = {}) => {\n  const x = exports.DOMString(value, options);\n  let c;\n  for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n    if (c > 255) {\n      throw makeException(TypeError, \"is not a valid ByteString\", options);\n    }\n  }\n\n  return x;\n};\n\nexports.USVString = (value, options = {}) => {\n  const S = exports.DOMString(value, options);\n  const n = S.length;\n  const U = [];\n  for (let i = 0; i < n; ++i) {\n    const c = S.charCodeAt(i);\n    if (c < 0xD800 || c > 0xDFFF) {\n      U.push(String.fromCodePoint(c));\n    } else if (0xDC00 <= c && c <= 0xDFFF) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else if (i === n - 1) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else {\n      const d = S.charCodeAt(i + 1);\n      if (0xDC00 <= d && d <= 0xDFFF) {\n        const a = c & 0x3FF;\n        const b = d & 0x3FF;\n        U.push(String.fromCodePoint((2 << 15) + ((2 << 9) * a) + b));\n        ++i;\n      } else {\n        U.push(String.fromCodePoint(0xFFFD));\n      }\n    }\n  }\n\n  return U.join(\"\");\n};\n\nexports.object = (value, options = {}) => {\n  if (value === null || (typeof value !== \"object\" && typeof value !== \"function\")) {\n    throw makeException(TypeError, \"is not an object\", options);\n  }\n\n  return value;\n};\n\nconst abByteLengthGetter =\n    Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\nconst sabByteLengthGetter =\n    typeof SharedArrayBuffer === \"function\" ?\n      Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, \"byteLength\").get :\n      null;\n\nfunction isNonSharedArrayBuffer(value) {\n  try {\n    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.\n    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)\n    abByteLengthGetter.call(value);\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isSharedArrayBuffer(value) {\n  try {\n    sabByteLengthGetter.call(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isArrayBufferDetached(value) {\n  try {\n    // eslint-disable-next-line no-new\n    new Uint8Array(value);\n    return false;\n  } catch {\n    return true;\n  }\n}\n\nexports.ArrayBuffer = (value, options = {}) => {\n  if (!isNonSharedArrayBuffer(value)) {\n    if (options.allowShared && !isSharedArrayBuffer(value)) {\n      throw makeException(TypeError, \"is not an ArrayBuffer or SharedArrayBuffer\", options);\n    }\n    throw makeException(TypeError, \"is not an ArrayBuffer\", options);\n  }\n  if (isArrayBufferDetached(value)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n  }\n\n  return value;\n};\n\nconst dvByteLengthGetter =\n    Object.getOwnPropertyDescriptor(DataView.prototype, \"byteLength\").get;\nexports.DataView = (value, options = {}) => {\n  try {\n    dvByteLengthGetter.call(value);\n  } catch (e) {\n    throw makeException(TypeError, \"is not a DataView\", options);\n  }\n\n  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n    throw makeException(TypeError, \"is backed by a SharedArrayBuffer, which is not allowed\", options);\n  }\n  if (isArrayBufferDetached(value.buffer)) {\n    throw makeException(TypeError, \"is backed by a detached ArrayBuffer\", options);\n  }\n\n  return value;\n};\n\n// Returns the unforgeable `TypedArray` constructor name or `undefined`,\n// if the `this` value isn't a valid `TypedArray` object.\n//\n// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag\nconst typedArrayNameGetter = Object.getOwnPropertyDescriptor(\n  Object.getPrototypeOf(Uint8Array).prototype,\n  Symbol.toStringTag\n).get;\n[\n  Int8Array,\n  Int16Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array,\n  Uint32Array,\n  Uint8ClampedArray,\n  Float32Array,\n  Float64Array\n].forEach(func => {\n  const { name } = func;\n  const article = /^[AEIOU]/u.test(name) ? \"an\" : \"a\";\n  exports[name] = (value, options = {}) => {\n    if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {\n      throw makeException(TypeError, `is not ${article} ${name} object`, options);\n    }\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n    }\n    if (isArrayBufferDetached(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n    }\n\n    return value;\n  };\n});\n\n// Common definitions\n\nexports.ArrayBufferView = (value, options = {}) => {\n  if (!ArrayBuffer.isView(value)) {\n    throw makeException(TypeError, \"is not a view on an ArrayBuffer or SharedArrayBuffer\", options);\n  }\n\n  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n    throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n  }\n\n  if (isArrayBufferDetached(value.buffer)) {\n    throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n  }\n  return value;\n};\n\nexports.BufferSource = (value, options = {}) => {\n  if (ArrayBuffer.isView(value)) {\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n    }\n\n    if (isArrayBufferDetached(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n    }\n    return value;\n  }\n\n  if (!options.allowShared && !isNonSharedArrayBuffer(value)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer or a view on one\", options);\n  }\n  if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer, SharedArrayBuffer, or a view on one\", options);\n  }\n  if (isArrayBufferDetached(value)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n  }\n\n  return value;\n};\n\nexports.DOMTimeStamp = exports[\"unsigned long long\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkMsRUFBRSxRQUFRO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWSxLQUFLLFdBQVc7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLEtBQUssV0FBVztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBOztBQUVBLFlBQVksZ0NBQWdDLGlCQUFpQjtBQUM3RCxhQUFhLGdDQUFnQyxnQkFBZ0I7O0FBRTdELGFBQWEsaUNBQWlDLGlCQUFpQjtBQUMvRCx5QkFBeUIsaUNBQWlDLGdCQUFnQjs7QUFFMUUsWUFBWSxpQ0FBaUMsaUJBQWlCO0FBQzlELHdCQUF3QixpQ0FBaUMsZ0JBQWdCOztBQUV6RSxvQkFBb0Isa0NBQWtDLGlCQUFpQjtBQUN2RSw2QkFBNkIsa0NBQWtDLGdCQUFnQjs7QUFFL0UsY0FBYyx1QkFBdUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLHVCQUF1QjtBQUNyRDs7QUFFQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLHVCQUF1QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBLHNDQUFzQztBQUN0QztBQUNBLCtDQUErQyxTQUFTLEVBQUUsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlyc29mdC8uL25vZGVfbW9kdWxlcy93ZWJpZGwtY29udmVyc2lvbnMvbGliL2luZGV4LmpzPzQ4ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFeGNlcHRpb24oRXJyb3JUeXBlLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmdsb2JhbHMpIHtcbiAgICBFcnJvclR5cGUgPSBvcHRpb25zLmdsb2JhbHNbRXJyb3JUeXBlLm5hbWVdO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3JUeXBlKGAke29wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IFwiVmFsdWVcIn0gJHttZXNzYWdlfS5gKTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgQmlnSW50IHdoaWNoIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXJcIiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmdsb2JhbHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucy5nbG9iYWxzLk51bWJlcih2YWx1ZSk7XG59XG5cbi8vIFJvdW5kIHggdG8gdGhlIG5lYXJlc3QgaW50ZWdlciwgY2hvb3NpbmcgdGhlIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28uXG5mdW5jdGlvbiBldmVuUm91bmQoeCkge1xuICAvLyBUaGVyZSBhcmUgZm91ciBjYXNlcyBmb3IgbnVtYmVycyB3aXRoIGZyYWN0aW9uYWwgcGFydCBiZWluZyAuNTpcbiAgLy9cbiAgLy8gY2FzZSB8ICAgICB4ICAgICB8IGZsb29yKHgpIHwgcm91bmQoeCkgfCBleHBlY3RlZCB8IHggPD4gMCB8IHggJSAxIHwgeCAmIDEgfCAgIGV4YW1wbGVcbiAgLy8gICAxICB8ICAybiArIDAuNSB8ICAybiAgICAgIHwgIDJuICsgMSAgfCAgMm4gICAgICB8ICAgPiAgICB8ICAwLjUgIHwgICAwICAgfCAgMC41IC0+ICAwXG4gIC8vICAgMiAgfCAgMm4gKyAxLjUgfCAgMm4gKyAxICB8ICAybiArIDIgIHwgIDJuICsgMiAgfCAgID4gICAgfCAgMC41ICB8ICAgMSAgIHwgIDEuNSAtPiAgMlxuICAvLyAgIDMgIHwgLTJuIC0gMC41IHwgLTJuIC0gMSAgfCAtMm4gICAgICB8IC0ybiAgICAgIHwgICA8ICAgIHwgLTAuNSAgfCAgIDAgICB8IC0wLjUgLT4gIDBcbiAgLy8gICA0ICB8IC0ybiAtIDEuNSB8IC0ybiAtIDIgIHwgLTJuIC0gMSAgfCAtMm4gLSAyICB8ICAgPCAgICB8IC0wLjUgIHwgICAxICAgfCAtMS41IC0+IC0yXG4gIC8vICh3aGVyZSBuIGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIpXG4gIC8vXG4gIC8vIEJyYW5jaCBoZXJlIGZvciBjYXNlcyAxIGFuZCA0XG4gIGlmICgoeCA+IDAgJiYgKHggJSAxKSA9PT0gKzAuNSAmJiAoeCAmIDEpID09PSAwKSB8fFxuICAgICAgICAoeCA8IDAgJiYgKHggJSAxKSA9PT0gLTAuNSAmJiAoeCAmIDEpID09PSAxKSkge1xuICAgIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aC5mbG9vcih4KSk7XG4gIH1cblxuICByZXR1cm4gY2Vuc29yTmVnYXRpdmVaZXJvKE1hdGgucm91bmQoeCkpO1xufVxuXG5mdW5jdGlvbiBpbnRlZ2VyUGFydChuKSB7XG4gIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aC50cnVuYyhuKSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbmZ1bmN0aW9uIG1vZHVsbyh4LCB5KSB7XG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jZXFuLW1vZHVsb1xuICAvLyBOb3RlIHRoYXQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ2NzU1OS8zMTkxIGRvZXMgTk9UIHdvcmsgZm9yIGxhcmdlIG1vZHVsb3NcbiAgY29uc3Qgc2lnbk1pZ2h0Tm90TWF0Y2ggPSB4ICUgeTtcbiAgaWYgKHNpZ24oeSkgIT09IHNpZ24oc2lnbk1pZ2h0Tm90TWF0Y2gpKSB7XG4gICAgcmV0dXJuIHNpZ25NaWdodE5vdE1hdGNoICsgeTtcbiAgfVxuICByZXR1cm4gc2lnbk1pZ2h0Tm90TWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGNlbnNvck5lZ2F0aXZlWmVybyh4KSB7XG4gIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKGJpdExlbmd0aCwgeyB1bnNpZ25lZCB9KSB7XG4gIGxldCBsb3dlckJvdW5kLCB1cHBlckJvdW5kO1xuICBpZiAodW5zaWduZWQpIHtcbiAgICBsb3dlckJvdW5kID0gMDtcbiAgICB1cHBlckJvdW5kID0gMiAqKiBiaXRMZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgIGxvd2VyQm91bmQgPSAtKDIgKiogKGJpdExlbmd0aCAtIDEpKTtcbiAgICB1cHBlckJvdW5kID0gMiAqKiAoYml0TGVuZ3RoIC0gMSkgLSAxO1xuICB9XG5cbiAgY29uc3QgdHdvVG9UaGVCaXRMZW5ndGggPSAyICoqIGJpdExlbmd0aDtcbiAgY29uc3QgdHdvVG9PbmVMZXNzVGhhblRoZUJpdExlbmd0aCA9IDIgKiogKGJpdExlbmd0aCAtIDEpO1xuXG4gIHJldHVybiAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGxldCB4ID0gdG9OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgIHggPSBjZW5zb3JOZWdhdGl2ZVplcm8oeCk7XG5cbiAgICBpZiAob3B0aW9ucy5lbmZvcmNlUmFuZ2UpIHtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhIGZpbml0ZSBudW1iZXJcIiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHggPSBpbnRlZ2VyUGFydCh4KTtcblxuICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oXG4gICAgICAgICAgVHlwZUVycm9yLFxuICAgICAgICAgIGBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWAsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc05hTih4KSAmJiBvcHRpb25zLmNsYW1wKSB7XG4gICAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xuICAgICAgeCA9IGV2ZW5Sb3VuZCh4KTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cbiAgICAvLyBNYXRoLnBvdygyLCA2NCkgaXMgbm90IGFjY3VyYXRlbHkgcmVwcmVzZW50YWJsZSBpbiBKYXZhU2NyaXB0LCBzbyB0cnkgdG8gYXZvaWQgdGhlc2UgcGVyLXNwZWMgb3BlcmF0aW9ucyBpZlxuICAgIC8vIHBvc3NpYmxlLiBIb3BlZnVsbHkgaXQncyBhbiBvcHRpbWl6YXRpb24gZm9yIHRoZSBub24tNjQtYml0TGVuZ3RoIGNhc2VzIHRvby5cbiAgICBpZiAoeCA+PSBsb3dlckJvdW5kICYmIHggPD0gdXBwZXJCb3VuZCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugd2lsbCBub3Qgd29yayBncmVhdCBmb3IgYml0TGVuZ3RoIG9mIDY0LCBidXQgb2ggd2VsbC4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICB4ID0gbW9kdWxvKHgsIHR3b1RvVGhlQml0TGVuZ3RoKTtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHggPj0gdHdvVG9PbmVMZXNzVGhhblRoZUJpdExlbmd0aCkge1xuICAgICAgcmV0dXJuIHggLSB0d29Ub1RoZUJpdExlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvbmdMb25nQ29udmVyc2lvbihiaXRMZW5ndGgsIHsgdW5zaWduZWQgfSkge1xuICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIGNvbnN0IGxvd2VyQm91bmQgPSB1bnNpZ25lZCA/IDAgOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgY29uc3QgYXNCaWdJbnROID0gdW5zaWduZWQgPyBCaWdJbnQuYXNVaW50TiA6IEJpZ0ludC5hc0ludE47XG5cbiAgcmV0dXJuICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgbGV0IHggPSB0b051bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcblxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VSYW5nZSkge1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGEgZmluaXRlIG51bWJlclwiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXG4gICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihcbiAgICAgICAgICBUeXBlRXJyb3IsXG4gICAgICAgICAgYGlzIG91dHNpZGUgdGhlIGFjY2VwdGVkIHJhbmdlIG9mICR7bG93ZXJCb3VuZH0gdG8gJHt1cHBlckJvdW5kfSwgaW5jbHVzaXZlYCxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdGlvbnMuY2xhbXApIHtcbiAgICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG4gICAgICB4ID0gZXZlblJvdW5kKHgpO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuICAgIHhCaWdJbnQgPSBhc0JpZ0ludE4oYml0TGVuZ3RoLCB4QmlnSW50KTtcbiAgICByZXR1cm4gTnVtYmVyKHhCaWdJbnQpO1xuICB9O1xufVxuXG5leHBvcnRzLmFueSA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0cy51bmRlZmluZWQgPSAoKSA9PiB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnRzLmJvb2xlYW4gPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn07XG5cbmV4cG9ydHMuYnl0ZSA9IGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xuZXhwb3J0cy5vY3RldCA9IGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IHRydWUgfSk7XG5cbmV4cG9ydHMuc2hvcnQgPSBjcmVhdGVJbnRlZ2VyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XG5leHBvcnRzW1widW5zaWduZWQgc2hvcnRcIl0gPSBjcmVhdGVJbnRlZ2VyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcblxuZXhwb3J0cy5sb25nID0gY3JlYXRlSW50ZWdlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xuZXhwb3J0c1tcInVuc2lnbmVkIGxvbmdcIl0gPSBjcmVhdGVJbnRlZ2VyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcblxuZXhwb3J0c1tcImxvbmcgbG9uZ1wiXSA9IGNyZWF0ZUxvbmdMb25nQ29udmVyc2lvbig2NCwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XG5leHBvcnRzW1widW5zaWduZWQgbG9uZyBsb25nXCJdID0gY3JlYXRlTG9uZ0xvbmdDb252ZXJzaW9uKDY0LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xuXG5leHBvcnRzLmRvdWJsZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHggPSB0b051bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYSBmaW5pdGUgZmxvYXRpbmctcG9pbnQgdmFsdWVcIiwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cbmV4cG9ydHNbXCJ1bnJlc3RyaWN0ZWQgZG91YmxlXCJdID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeCA9IHRvTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcblxuICByZXR1cm4geDtcbn07XG5cbmV4cG9ydHMuZmxvYXQgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB4ID0gdG9OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGEgZmluaXRlIGZsb2F0aW5nLXBvaW50IHZhbHVlXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5pcyh4LCAtMCkpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGNvbnN0IHkgPSBNYXRoLmZyb3VuZCh4KTtcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG91dHNpZGUgdGhlIHJhbmdlIG9mIGEgc2luZ2xlLXByZWNpc2lvbiBmbG9hdGluZy1wb2ludCB2YWx1ZVwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB5O1xufTtcblxuZXhwb3J0c1tcInVucmVzdHJpY3RlZCBmbG9hdFwiXSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHggPSB0b051bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzTmFOKHgpKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBpZiAoT2JqZWN0LmlzKHgsIC0wKSkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguZnJvdW5kKHgpO1xufTtcblxuZXhwb3J0cy5ET01TdHJpbmcgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy50cmVhdE51bGxBc0VtcHR5U3RyaW5nICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSBzeW1ib2wsIHdoaWNoIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmdcIiwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBTdHJpbmdDdG9yID0gb3B0aW9ucy5nbG9iYWxzID8gb3B0aW9ucy5nbG9iYWxzLlN0cmluZyA6IFN0cmluZztcbiAgcmV0dXJuIFN0cmluZ0N0b3IodmFsdWUpO1xufTtcblxuZXhwb3J0cy5CeXRlU3RyaW5nID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeCA9IGV4cG9ydHMuRE9NU3RyaW5nKHZhbHVlLCBvcHRpb25zKTtcbiAgbGV0IGM7XG4gIGZvciAobGV0IGkgPSAwOyAoYyA9IHguY29kZVBvaW50QXQoaSkpICE9PSB1bmRlZmluZWQ7ICsraSkge1xuICAgIGlmIChjID4gMjU1KSB7XG4gICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYSB2YWxpZCBCeXRlU3RyaW5nXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB4O1xufTtcblxuZXhwb3J0cy5VU1ZTdHJpbmcgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBTID0gZXhwb3J0cy5ET01TdHJpbmcodmFsdWUsIG9wdGlvbnMpO1xuICBjb25zdCBuID0gUy5sZW5ndGg7XG4gIGNvbnN0IFUgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBjID0gUy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPiAweERGRkYpIHtcbiAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjKSk7XG4gICAgfSBlbHNlIGlmICgweERDMDAgPD0gYyAmJiBjIDw9IDB4REZGRikge1xuICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbiAtIDEpIHtcbiAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZCA9IFMuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAoMHhEQzAwIDw9IGQgJiYgZCA8PSAweERGRkYpIHtcbiAgICAgICAgY29uc3QgYSA9IGMgJiAweDNGRjtcbiAgICAgICAgY29uc3QgYiA9IGQgJiAweDNGRjtcbiAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KCgyIDw8IDE1KSArICgoMiA8PCA5KSAqIGEpICsgYikpO1xuICAgICAgICArK2k7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFUuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydHMub2JqZWN0ID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGFuIG9iamVjdFwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IGFiQnl0ZUxlbmd0aEdldHRlciA9XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUJ1ZmZlci5wcm90b3R5cGUsIFwiYnl0ZUxlbmd0aFwiKS5nZXQ7XG5jb25zdCBzYWJCeXRlTGVuZ3RoR2V0dGVyID1cbiAgICB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiA/XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNoYXJlZEFycmF5QnVmZmVyLnByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpLmdldCA6XG4gICAgICBudWxsO1xuXG5mdW5jdGlvbiBpc05vblNoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gVGhpcyB3aWxsIHRocm93IG9uIFNoYXJlZEFycmF5QnVmZmVycywgYnV0IG5vdCBkZXRhY2hlZCBBcnJheUJ1ZmZlcnMuXG4gICAgLy8gKFRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIHRocm93LCBidXQgdGhlIHNwZWMgY29uZmxpY3RzIHdpdGggaW1wbGVtZW50YXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy82NzgpXG4gICAgYWJCeXRlTGVuZ3RoR2V0dGVyLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgc2FiQnl0ZUxlbmd0aEdldHRlci5jYWxsKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJEZXRhY2hlZCh2YWx1ZSkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnRzLkFycmF5QnVmZmVyID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKCFpc05vblNoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIGlmIChvcHRpb25zLmFsbG93U2hhcmVkICYmICFpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYW4gQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJEZXRhY2hlZCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZHZCeXRlTGVuZ3RoR2V0dGVyID1cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKERhdGFWaWV3LnByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpLmdldDtcbmV4cG9ydHMuRGF0YVZpZXcgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICB0cnkge1xuICAgIGR2Qnl0ZUxlbmd0aEdldHRlci5jYWxsKHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhIERhdGFWaWV3XCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbG93U2hhcmVkICYmIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUuYnVmZmVyKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGJhY2tlZCBieSBhIFNoYXJlZEFycmF5QnVmZmVyLCB3aGljaCBpcyBub3QgYWxsb3dlZFwiLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlckRldGFjaGVkKHZhbHVlLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBiYWNrZWQgYnkgYSBkZXRhY2hlZCBBcnJheUJ1ZmZlclwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHVuZm9yZ2VhYmxlIGBUeXBlZEFycmF5YCBjb25zdHJ1Y3RvciBuYW1lIG9yIGB1bmRlZmluZWRgLFxuLy8gaWYgdGhlIGB0aGlzYCB2YWx1ZSBpc24ndCBhIHZhbGlkIGBUeXBlZEFycmF5YCBvYmplY3QuXG4vL1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtJXR5cGVkYXJyYXklLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5jb25zdCB0eXBlZEFycmF5TmFtZUdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5KS5wcm90b3R5cGUsXG4gIFN5bWJvbC50b1N0cmluZ1RhZ1xuKS5nZXQ7XG5bXG4gIEludDhBcnJheSxcbiAgSW50MTZBcnJheSxcbiAgSW50MzJBcnJheSxcbiAgVWludDhBcnJheSxcbiAgVWludDE2QXJyYXksXG4gIFVpbnQzMkFycmF5LFxuICBVaW50OENsYW1wZWRBcnJheSxcbiAgRmxvYXQzMkFycmF5LFxuICBGbG9hdDY0QXJyYXlcbl0uZm9yRWFjaChmdW5jID0+IHtcbiAgY29uc3QgeyBuYW1lIH0gPSBmdW5jO1xuICBjb25zdCBhcnRpY2xlID0gL15bQUVJT1VdL3UudGVzdChuYW1lKSA/IFwiYW5cIiA6IFwiYVwiO1xuICBleHBvcnRzW25hbWVdID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHwgdHlwZWRBcnJheU5hbWVHZXR0ZXIuY2FsbCh2YWx1ZSkgIT09IG5hbWUpIHtcbiAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBgaXMgbm90ICR7YXJ0aWNsZX0gJHtuYW1lfSBvYmplY3RgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFsbG93U2hhcmVkICYmIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUuYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSB2aWV3IG9uIGEgU2hhcmVkQXJyYXlCdWZmZXIsIHdoaWNoIGlzIG5vdCBhbGxvd2VkXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUJ1ZmZlckRldGFjaGVkKHZhbHVlLmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgdmlldyBvbiBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0pO1xuXG4vLyBDb21tb24gZGVmaW5pdGlvbnNcblxuZXhwb3J0cy5BcnJheUJ1ZmZlclZpZXcgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbG93U2hhcmVkICYmIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUuYnVmZmVyKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgdmlldyBvbiBhIFNoYXJlZEFycmF5QnVmZmVyLCB3aGljaCBpcyBub3QgYWxsb3dlZFwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5QnVmZmVyRGV0YWNoZWQodmFsdWUuYnVmZmVyKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgdmlldyBvbiBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydHMuQnVmZmVyU291cmNlID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIHZpZXcgb24gYSBTaGFyZWRBcnJheUJ1ZmZlciwgd2hpY2ggaXMgbm90IGFsbG93ZWRcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXlCdWZmZXJEZXRhY2hlZCh2YWx1ZS5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIHZpZXcgb24gYSBkZXRhY2hlZCBBcnJheUJ1ZmZlclwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbG93U2hhcmVkICYmICFpc05vblNoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhbiBBcnJheUJ1ZmZlciBvciBhIHZpZXcgb24gb25lXCIsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChvcHRpb25zLmFsbG93U2hhcmVkICYmICFpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSAmJiAhaXNOb25TaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYW4gQXJyYXlCdWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyLCBvciBhIHZpZXcgb24gb25lXCIsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0FycmF5QnVmZmVyRGV0YWNoZWQodmFsdWUpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSBkZXRhY2hlZCBBcnJheUJ1ZmZlclwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydHMuRE9NVGltZVN0YW1wID0gZXhwb3J0c1tcInVuc2lnbmVkIGxvbmcgbG9uZ1wiXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ })

};
;